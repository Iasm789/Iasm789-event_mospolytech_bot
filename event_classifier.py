"""Модуль для классификации текстовых сообщений на предмет наличия событий."""

import re
from dataclasses import dataclass
from typing import List, Dict


@dataclass
class TextAnalysis:
    """Результат анализа текста на наличие признаков события."""
    is_event: bool
    keywords_found: List[str]
    has_time_references: bool
    has_location_references: bool
    has_date_patterns: bool
    total_score: int


class EventClassifier:
    """Классификатор для определения является ли сообщение описанием события."""
    
    def __init__(self):
        # Ключевые слова по категориям
        self.event_keywords = {
            # Образовательные события
            'лекция', 'семинар', 'вебинар', 'мастер-класс', 'практикум',
            'консультация', 'защита', 'день открытых дверей', 'дебаты',
            'тренинг', 'воркшоп', 'хакатон', 'курс', 'школа', 'конференция',
            'студенческая конференция', 'обучение', 'учебный',
            
            # Профориентационные события
            'день карьеры', 'карьерная', 'профориентац', 'встреча с',
            'стажировка', 'рекрутмент', 'найм', 'собеседование',
            
            # Конкурсы и фестивали
            'конкурс', 'фестиваль', 'творчества', 'конкурс проектов',
            'инжиниринговый конкурс', 'литературный конкурс', 'фотоконкурс',
            'фотография', 'медиа-фестиваль', 'искусств',
            
            # Выставки
            'выставка', 'экспозиция', 'галерея', 'инженерных проектов',
            'технических проектов', 'художественная выставка',
            
            # Культурные и творческие
            'концерт', 'выступление', 'вокальный ансамбль', 'танец',
            'танцевальное', 'лаборатория танцев', 'кино', 'кино-показ',
            'фильм', 'иллюзион', 'шоу', 'праздник', 'вечер',
            
            # Волонтёрские и социальные
            'волонтёр', 'волонтер', 'волонтёрск', 'волонтерск', 'акция',
            'социальн', 'благотворительн', 'помощь', 'инициатива',
            'общественн', 'проект', 'сообщество',
            
            # Студенческая жизнь
            'встреча студент', 'студсовет', 'студенческий', 'клуб',
            'мероприятие', 'событие', 'собрание', 'вечер знакомств'
        }
        # Временные индикаторы по категориям
        self.time_indicators = {
            # Общие указатели времени
            'когда', 'дата', 'время', 'график', 'расписание',
            
            # Дни недели
            'понедельник', 'вторник', 'среда', 'четверг', 'пятница',
            'суббота', 'воскресенье', 'будни', 'выходные',
            
            # Месяцы
            'январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
            'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь',
            
            # Относительные указатели
            'сегодня', 'завтра', 'послезавтра', 'скоро', 'через',
            'на следующей неделе', 'на этой неделе', 'в этом месяце',
            
            # Части дня
            'утро', 'день', 'вечер', 'ночь', 'полдень', 'полночь',
            'с утра', 'до вечера', 'после обеда',
            
            # Периоды
            'начало', 'середина', 'конец', 'в течение', 'весь день',
            'ежедневно', 'еженедельно', 'ежемесячно'
        }
        # Индикаторы места по категориям
        self.location_indicators = {
            # Общие указатели места
            'где', 'место', 'адрес', 'локация', 'площадка', 'территория',
            
            # Учебные помещения
            'аудитория', 'корпус', 'этаж', 'кабинет', 'комната', 'класс',
            'лаборатория', 'мастерская', 'актовый зал', 'спортзал',
            
            # Конференц-пространства
            'конференц-зал', 'зал', 'холл', 'фойе', 'атриум',
            'выставочный центр', 'павильон',
            
            # Спортивные объекты
            'стадион', 'манеж', 'бассейн', 'корт', 'площадка',
            'спорткомплекс', 'арена',
            
            # Культурные места
            'театр', 'кинотеатр', 'музей', 'галерея', 'концертный зал',
            'дворец культуры', 'библиотека',
            
            # Онлайн-платформы
            'онлайн', 'трансляция', 'стрим',
            'zoom', 'discord', 'teams', 'skype', 'webinar',
            
            # Общественные места
            'ресторан', 'кафе', 'офис', 'парк', 'сквер', 'площадь',
            'центр', 'дом культуры'
        }
        # Паттерны для поиска дат и времени
        self.date_patterns = [
            # Стандартные форматы дат
            r'\d{1,2}\s*[\.\/-]\s*\d{1,2}\s*[\.\/-]\s*\d{2,4}',  # 25.12.2024, 25/12/24
            r'\d{4}\s*[\.\/-]\s*\d{1,2}\s*[\.\/-]\s*\d{1,2}',    # 2024-12-25
            
            # Даты с названиями месяцев
            r'\d{1,2}\s+(января|февраля|марта|апреля|мая|июня|июля|августа|сентября|октября|ноября|декабря)',
            r'(января|февраля|марта|апреля|мая|июня|июля|августа|сентября|октября|ноября|декабря)\s+\d{1,2}',
            
            # Время
            r'(в|с|до)\s+\d{1,2}:\d{2}',           # в 15:00, с 9:00, до 18:00
            r'\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}',  # 10:00-18:00
            r'\d{1,2}[\.:]\d{2}',                   # 15.00 или 15:00
            
            # Относительные даты с числами
            r'через\s+\d+\s+(день|дня|дней|недел[юьи]|месяц[ае]?в?)',
            r'(\d+|несколько)\s+(день|дня|дней|недел[юьи]|месяц[ае]?в?)\s+назад',
            
            # Периоды
            r'с\s+\d{1,2}\s+по\s+\d{1,2}\s+(января|февраля|марта|апреля|мая|июня|июля|августа|сентября|октября|ноября|декабря)',
            r'с\s+\d{1,2}\.\d{2}\s+по\s+\d{1,2}\.\d{2}',
            
            # Дни недели с датами
            r'(понедельник|вторник|среду|четверг|пятницу|субботу|воскресенье),?\s+\d{1,2}\s+(января|февраля|марта|апреля|мая|июня|июля|августа|сентября|октября|ноября|декабря)'
        ]

    def _check_keywords(self, text: str) -> int:
        """Проверка наличия ключевых слов в тексте."""
        count = sum(1 for keyword in self.event_keywords if keyword in text)
        return min(count, 2)

    def _check_time_references(self, text: str) -> int:
        """Проверка наличия указаний на время."""
        count = sum(1 for indicator in self.time_indicators if indicator in text)
        return min(count, 1)

    def _check_location_references(self, text: str) -> int:
        """Проверка наличия указаний на место."""
        count = sum(1 for indicator in self.location_indicators if indicator in text)
        return min(count, 1)

    def _check_date_patterns(self, text: str) -> int:
        """Проверка наличия паттернов дат и времени."""
        for pattern in self.date_patterns:
            if re.search(pattern, text):
                return 1
        return 0

    def _check_structure(self, text: str) -> int:
        """Проверка структуры текста на наличие всех необходимых компонентов."""
        has_what_where_when = (
            any(keyword in text for keyword in self.event_keywords) and
            any(indicator in text for indicator in self.time_indicators) and
            any(indicator in text for indicator in self.location_indicators)
        )
        return 1 if has_what_where_when else 0

    def is_event(self, text: str) -> bool:
        """Определяет, является ли текст описанием события."""
        return self.analyze_text(text).is_event

    def analyze_text(self, text: str) -> TextAnalysis:
        """Подробный анализ текста на признаки события."""
        text_lower = text.lower()
        
        # Собираем оценки по разным критериям
        scores = {
            'keywords': self._check_keywords(text_lower),
            'time_references': self._check_time_references(text_lower),
            'location_references': self._check_location_references(text_lower),
            'date_patterns': self._check_date_patterns(text_lower),
            'structure': self._check_structure(text_lower)
        }
        total_score = sum(scores.values())
        
        # Формируем результат анализа
        return TextAnalysis(
            is_event=total_score >= 2,
            keywords_found=[kw for kw in self.event_keywords if kw in text_lower],
            has_time_references=any(ind in text_lower for ind in self.time_indicators),
            has_location_references=any(ind in text_lower for ind in self.location_indicators),
            has_date_patterns=any(re.search(pattern, text) for pattern in self.date_patterns),
            total_score=total_score
        )